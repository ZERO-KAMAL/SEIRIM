{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.window = global.window || {}));\n})(this, function (exports) {\n  'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  /*!\n   * ScrollSmoother 3.12.2\n   * https://greensock.com\n   *\n   * @license Copyright 2008-2023, GreenSock. All rights reserved.\n   * Subject to the terms at https://greensock.com/standard-license or for\n   * Club GreenSock members, the agreement issued with that membership.\n   * @author: Jack Doyle, jack@greensock.com\n  */\n  var gsap,\n    _coreInitted,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _toArray,\n    _clamp,\n    ScrollTrigger,\n    _mainInstance,\n    _expo,\n    _getVelocityProp,\n    _inputObserver,\n    _context,\n    _onResizeDelayedCall,\n    _windowExists = function _windowExists() {\n      return typeof window !== \"undefined\";\n    },\n    _getGSAP = function _getGSAP() {\n      return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n    },\n    _round = function _round(value) {\n      return Math.round(value * 100000) / 100000 || 0;\n    },\n    _maxScroll = function _maxScroll(scroller) {\n      return ScrollTrigger.maxScroll(scroller || _win);\n    },\n    _autoDistance = function _autoDistance(el, progress) {\n      var parent = el.parentNode || _docEl,\n        b1 = el.getBoundingClientRect(),\n        b2 = parent.getBoundingClientRect(),\n        gapTop = b2.top - b1.top,\n        gapBottom = b2.bottom - b1.bottom,\n        change = (Math.abs(gapTop) > Math.abs(gapBottom) ? gapTop : gapBottom) / (1 - progress),\n        offset = -change * progress,\n        ratio,\n        extraChange;\n      if (change > 0) {\n        ratio = b2.height / (_win.innerHeight + b2.height);\n        extraChange = ratio === 0.5 ? b2.height * 2 : Math.min(b2.height, Math.abs(-change * ratio / (2 * ratio - 1))) * 2 * (progress || 1);\n        offset += progress ? -extraChange * progress : -extraChange / 2;\n        change += extraChange;\n      }\n      return {\n        change: change,\n        offset: offset\n      };\n    },\n    _wrap = function _wrap(el) {\n      var wrapper = _doc.querySelector(\".ScrollSmoother-wrapper\");\n      if (!wrapper) {\n        wrapper = _doc.createElement(\"div\");\n        wrapper.classList.add(\"ScrollSmoother-wrapper\");\n        el.parentNode.insertBefore(wrapper, el);\n        wrapper.appendChild(el);\n      }\n      return wrapper;\n    };\n  var ScrollSmoother = function () {\n    function ScrollSmoother(vars) {\n      var _this = this;\n      _coreInitted || ScrollSmoother.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollSmoother)\");\n      vars = this.vars = vars || {};\n      _mainInstance && _mainInstance.kill();\n      _mainInstance = this;\n      _context(this);\n      var _vars = vars,\n        smoothTouch = _vars.smoothTouch,\n        _onUpdate = _vars.onUpdate,\n        onStop = _vars.onStop,\n        smooth = _vars.smooth,\n        onFocusIn = _vars.onFocusIn,\n        normalizeScroll = _vars.normalizeScroll,\n        wholePixels = _vars.wholePixels,\n        content,\n        wrapper,\n        height,\n        mainST,\n        effects,\n        sections,\n        intervalID,\n        wrapperCSS,\n        contentCSS,\n        paused,\n        pausedNormalizer,\n        recordedRefreshScroll,\n        recordedRefreshScrub,\n        self = this,\n        effectsPrefix = vars.effectsPrefix || \"\",\n        scrollFunc = ScrollTrigger.getScrollFunc(_win),\n        smoothDuration = ScrollTrigger.isTouch === 1 ? smoothTouch === true ? 0.8 : parseFloat(smoothTouch) || 0 : smooth === 0 || smooth === false ? 0 : parseFloat(smooth) || 0.8,\n        speed = smoothDuration && +vars.speed || 1,\n        currentY = 0,\n        delta = 0,\n        startupPhase = 1,\n        tracker = _getVelocityProp(0),\n        updateVelocity = function updateVelocity() {\n          return tracker.update(-currentY);\n        },\n        scroll = {\n          y: 0\n        },\n        removeScroll = function removeScroll() {\n          return content.style.overflow = \"visible\";\n        },\n        isProxyScrolling,\n        killScrub = function killScrub(trigger) {\n          trigger.update();\n          var scrub = trigger.getTween();\n          if (scrub) {\n            scrub.pause();\n            scrub._time = scrub._dur;\n            scrub._tTime = scrub._tDur;\n          }\n          isProxyScrolling = false;\n          trigger.animation.progress(trigger.progress, true);\n        },\n        render = function render(y, force) {\n          if (y !== currentY && !paused || force) {\n            wholePixels && (y = Math.round(y));\n            if (smoothDuration) {\n              content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n              content._gsap.y = y + \"px\";\n            }\n            delta = y - currentY;\n            currentY = y;\n            ScrollTrigger.isUpdating || ScrollSmoother.isRefreshing || ScrollTrigger.update();\n          }\n        },\n        scrollTop = function scrollTop(value) {\n          if (arguments.length) {\n            value < 0 && (value = 0);\n            scroll.y = -value;\n            isProxyScrolling = true;\n            paused ? currentY = -value : render(-value);\n            ScrollTrigger.isRefreshing ? mainST.update() : scrollFunc(value / speed);\n            return this;\n          }\n          return -currentY;\n        },\n        resizeObserver = typeof ResizeObserver !== \"undefined\" && vars.autoResize !== false && new ResizeObserver(function () {\n          if (!ScrollTrigger.isRefreshing) {\n            var max = _maxScroll(wrapper) * speed;\n            max < -currentY && scrollTop(max);\n            _onResizeDelayedCall.restart(true);\n          }\n        }),\n        lastFocusElement,\n        _onFocusIn = function _onFocusIn(e) {\n          wrapper.scrollTop = 0;\n          if (e.target.contains && e.target.contains(wrapper) || onFocusIn && onFocusIn(_this, e) === false) {\n            return;\n          }\n          ScrollTrigger.isInViewport(e.target) || e.target === lastFocusElement || _this.scrollTo(e.target, false, \"center center\");\n          lastFocusElement = e.target;\n        },\n        _transformPosition = function _transformPosition(position, st) {\n          if (position < st.start) {\n            return position;\n          }\n          var ratio = isNaN(st.ratio) ? 1 : st.ratio,\n            change = st.end - st.start,\n            distance = position - st.start,\n            offset = st.offset || 0,\n            pins = st.pins || [],\n            pinOffset = pins.offset || 0,\n            progressOffset = st._startClamp && st.start <= 0 || st.pins && st.pins.offset ? 0 : st._endClamp && st.end === _maxScroll() ? 1 : 0.5;\n          pins.forEach(function (p) {\n            change -= p.distance;\n            if (p.nativeStart <= position) {\n              distance -= p.distance;\n            }\n          });\n          if (pinOffset) {\n            distance *= (change - pinOffset / ratio) / change;\n          }\n          return position + (distance - offset * progressOffset) / ratio - distance;\n        },\n        adjustEffectRelatedTriggers = function adjustEffectRelatedTriggers(st, triggers, partial) {\n          partial || (st.pins.length = st.pins.offset = 0);\n          var pins = st.pins,\n            markers = st.markers,\n            dif,\n            isClamped,\n            start,\n            end,\n            nativeStart,\n            nativeEnd,\n            i,\n            trig;\n          for (i = 0; i < triggers.length; i++) {\n            trig = triggers[i];\n            if (st.trigger && trig.trigger && st !== trig && (trig.trigger === st.trigger || trig.pinnedContainer === st.trigger || st.trigger.contains(trig.trigger))) {\n              nativeStart = trig._startNative || trig._startClamp || trig.start;\n              nativeEnd = trig._endNative || trig._endClamp || trig.end;\n              start = _transformPosition(nativeStart, st);\n              end = trig.pin && nativeEnd > 0 ? start + (nativeEnd - nativeStart) : _transformPosition(nativeEnd, st);\n              trig.setPositions(start, end, true, (trig._startClamp ? Math.max(0, start) : start) - nativeStart);\n              trig.markerStart && markers.push(gsap.quickSetter([trig.markerStart, trig.markerEnd], \"y\", \"px\"));\n              if (trig.pin && trig.end > 0 && !partial) {\n                dif = trig.end - trig.start;\n                isClamped = st._startClamp && trig.start < 0;\n                if (isClamped) {\n                  if (st.start > 0) {\n                    st.setPositions(0, st.end + (st._startNative - st.start), true);\n                    adjustEffectRelatedTriggers(st, triggers);\n                    return;\n                  }\n                  dif += trig.start;\n                  pins.offset = -trig.start;\n                }\n                pins.push({\n                  start: trig.start,\n                  nativeStart: nativeStart,\n                  end: trig.end,\n                  distance: dif,\n                  trig: trig\n                });\n                st.setPositions(st.start, st.end + (isClamped ? -trig.start : dif), true);\n              }\n            }\n          }\n        },\n        adjustParallaxPosition = function adjustParallaxPosition(triggers, createdAfterEffectWasApplied) {\n          effects.forEach(function (st) {\n            return adjustEffectRelatedTriggers(st, triggers, createdAfterEffectWasApplied);\n          });\n        },\n        onRefresh = function onRefresh() {\n          removeScroll();\n          requestAnimationFrame(removeScroll);\n          if (effects) {\n            ScrollTrigger.getAll().forEach(function (st) {\n              st._startNative = st.start;\n              st._endNative = st.end;\n            });\n            effects.forEach(function (st) {\n              var start = st._startClamp || st.start,\n                end = st.autoSpeed ? Math.min(_maxScroll(), st.end) : start + Math.abs((st.end - start) / st.ratio),\n                offset = end - st.end;\n              start -= offset / 2;\n              end -= offset / 2;\n              if (start > end) {\n                var s = start;\n                start = end;\n                end = s;\n              }\n              if (st._startClamp && start < 0) {\n                end = st.ratio < 0 ? _maxScroll() : st.end / st.ratio;\n                offset = end - st.end;\n                start = 0;\n              } else if (st.ratio < 0 || st._endClamp && end >= _maxScroll()) {\n                end = _maxScroll();\n                start = st.ratio < 0 ? 0 : st.ratio > 1 ? 0 : end - (end - st.start) / st.ratio;\n                offset = (end - start) * st.ratio - (st.end - st.start);\n              }\n              st.offset = offset || 0.0001;\n              st.pins.length = st.pins.offset = 0;\n              st.setPositions(start, end, true);\n            });\n            adjustParallaxPosition(ScrollTrigger.sort());\n          }\n          tracker.reset();\n        },\n        addOnRefresh = function addOnRefresh() {\n          return ScrollTrigger.addEventListener(\"refresh\", onRefresh);\n        },\n        restoreEffects = function restoreEffects() {\n          return effects && effects.forEach(function (st) {\n            return st.vars.onRefresh(st);\n          });\n        },\n        revertEffects = function revertEffects() {\n          effects && effects.forEach(function (st) {\n            return st.vars.onRefreshInit(st);\n          });\n          return restoreEffects;\n        },\n        effectValueGetter = function effectValueGetter(name, value, index, el) {\n          return function () {\n            var v = typeof value === \"function\" ? value(index, el) : value;\n            v || v === 0 || (v = el.getAttribute(\"data-\" + effectsPrefix + name) || (name === \"speed\" ? 1 : 0));\n            el.setAttribute(\"data-\" + effectsPrefix + name, v);\n            var clamp = (v + \"\").substr(0, 6) === \"clamp(\";\n            return {\n              clamp: clamp,\n              value: clamp ? v.substr(6, v.length - 7) : v\n            };\n          };\n        },\n        createEffect = function createEffect(el, speed, lag, index, effectsPadding) {\n          effectsPadding = (typeof effectsPadding === \"function\" ? effectsPadding(index, el) : effectsPadding) || 0;\n          var getSpeed = effectValueGetter(\"speed\", speed, index, el),\n            getLag = effectValueGetter(\"lag\", lag, index, el),\n            startY = gsap.getProperty(el, \"y\"),\n            cache = el._gsap,\n            ratio,\n            st,\n            autoSpeed,\n            scrub,\n            progressOffset,\n            yOffset,\n            pins = [],\n            initDynamicValues = function initDynamicValues() {\n              speed = getSpeed();\n              lag = parseFloat(getLag().value);\n              ratio = parseFloat(speed.value) || 1;\n              autoSpeed = speed.value === \"auto\";\n              progressOffset = autoSpeed || st && st._startClamp && st.start <= 0 || pins.offset ? 0 : st && st._endClamp && st.end === _maxScroll() ? 1 : 0.5;\n              scrub && scrub.kill();\n              scrub = lag && gsap.to(el, {\n                ease: _expo,\n                overwrite: false,\n                y: \"+=0\",\n                duration: lag\n              });\n              if (st) {\n                st.ratio = ratio;\n                st.autoSpeed = autoSpeed;\n              }\n            },\n            revert = function revert() {\n              cache.y = startY + \"px\";\n              cache.renderTransform(1);\n              initDynamicValues();\n            },\n            markers = [],\n            change = 0,\n            updateChange = function updateChange(self) {\n              if (autoSpeed) {\n                revert();\n                var auto = _autoDistance(el, _clamp(0, 1, -self.start / (self.end - self.start)));\n                change = auto.change;\n                yOffset = auto.offset;\n              } else {\n                yOffset = pins.offset || 0;\n                change = (self.end - self.start - yOffset) * (1 - ratio);\n              }\n              pins.forEach(function (p) {\n                return change -= p.distance * (1 - ratio);\n              });\n              self.offset = change || 0.001;\n              self.vars.onUpdate(self);\n              scrub && scrub.progress(1);\n            };\n          initDynamicValues();\n          if (ratio !== 1 || autoSpeed || scrub) {\n            st = ScrollTrigger.create({\n              trigger: autoSpeed ? el.parentNode : el,\n              start: function start() {\n                return speed.clamp ? \"clamp(top bottom+=\" + effectsPadding + \")\" : \"top bottom+=\" + effectsPadding;\n              },\n              end: function end() {\n                return speed.value < 0 ? \"max\" : speed.clamp ? \"clamp(bottom top-=\" + effectsPadding + \")\" : \"bottom top-=\" + effectsPadding;\n              },\n              scroller: wrapper,\n              scrub: true,\n              refreshPriority: -999,\n              onRefreshInit: revert,\n              onRefresh: updateChange,\n              onKill: function onKill(self) {\n                var i = effects.indexOf(self);\n                i >= 0 && effects.splice(i, 1);\n                revert();\n              },\n              onUpdate: function onUpdate(self) {\n                var y = startY + change * (self.progress - progressOffset),\n                  i = pins.length,\n                  extraY = 0,\n                  pin,\n                  scrollY,\n                  end;\n                if (self.offset) {\n                  if (i) {\n                    scrollY = -currentY;\n                    end = self.end;\n                    while (i--) {\n                      pin = pins[i];\n                      if (pin.trig.isActive || scrollY >= pin.start && scrollY <= pin.end) {\n                        if (scrub) {\n                          pin.trig.progress += pin.trig.direction < 0 ? 0.001 : -0.001;\n                          pin.trig.update(0, 0, 1);\n                          scrub.resetTo(\"y\", parseFloat(cache.y), -delta, true);\n                          startupPhase && scrub.progress(1);\n                        }\n                        return;\n                      }\n                      scrollY > pin.end && (extraY += pin.distance);\n                      end -= pin.distance;\n                    }\n                    y = startY + extraY + change * ((gsap.utils.clamp(self.start, self.end, scrollY) - self.start - extraY) / (end - self.start) - progressOffset);\n                  }\n                  markers.length && !autoSpeed && markers.forEach(function (setter) {\n                    return setter(y - extraY);\n                  });\n                  y = _round(y + yOffset);\n                  if (scrub) {\n                    scrub.resetTo(\"y\", y, -delta, true);\n                    startupPhase && scrub.progress(1);\n                  } else {\n                    cache.y = y + \"px\";\n                    cache.renderTransform(1);\n                  }\n                }\n              }\n            });\n            updateChange(st);\n            gsap.core.getCache(st.trigger).stRevert = revertEffects;\n            st.startY = startY;\n            st.pins = pins;\n            st.markers = markers;\n            st.ratio = ratio;\n            st.autoSpeed = autoSpeed;\n            el.style.willChange = \"transform\";\n          }\n          return st;\n        };\n      addOnRefresh();\n      ScrollTrigger.addEventListener(\"killAll\", addOnRefresh);\n      gsap.delayedCall(0.5, function () {\n        return startupPhase = 0;\n      });\n      this.scrollTop = scrollTop;\n      this.scrollTo = function (target, smooth, position) {\n        var p = gsap.utils.clamp(0, _maxScroll(), isNaN(target) ? _this.offset(target, position) : +target);\n        !smooth ? scrollTop(p) : paused ? gsap.to(_this, {\n          duration: smoothDuration,\n          scrollTop: p,\n          overwrite: \"auto\",\n          ease: _expo\n        }) : scrollFunc(p);\n      };\n      this.offset = function (target, position) {\n        target = _toArray(target)[0];\n        var cssText = target.style.cssText,\n          st = ScrollTrigger.create({\n            trigger: target,\n            start: position || \"top top\"\n          }),\n          y;\n        if (effects) {\n          startupPhase ? ScrollTrigger.refresh() : adjustParallaxPosition([st], true);\n        }\n        y = st.start / speed;\n        st.kill(false);\n        target.style.cssText = cssText;\n        gsap.core.getCache(target).uncache = 1;\n        return y;\n      };\n      function refreshHeight() {\n        height = content.clientHeight;\n        content.style.overflow = \"visible\";\n        _body.style.height = _win.innerHeight + (height - _win.innerHeight) / speed + \"px\";\n        return height - _win.innerHeight;\n      }\n      this.content = function (element) {\n        if (arguments.length) {\n          var newContent = _toArray(element || \"#smooth-content\")[0] || console.warn(\"ScrollSmoother needs a valid content element.\") || _body.children[0];\n          if (newContent !== content) {\n            content = newContent;\n            contentCSS = content.getAttribute(\"style\") || \"\";\n            resizeObserver && resizeObserver.observe(content);\n            gsap.set(content, {\n              overflow: \"visible\",\n              width: \"100%\",\n              boxSizing: \"border-box\",\n              y: \"+=0\"\n            });\n            smoothDuration || gsap.set(content, {\n              clearProps: \"transform\"\n            });\n          }\n          return this;\n        }\n        return content;\n      };\n      this.wrapper = function (element) {\n        if (arguments.length) {\n          wrapper = _toArray(element || \"#smooth-wrapper\")[0] || _wrap(content);\n          wrapperCSS = wrapper.getAttribute(\"style\") || \"\";\n          refreshHeight();\n          gsap.set(wrapper, smoothDuration ? {\n            overflow: \"hidden\",\n            position: \"fixed\",\n            height: \"100%\",\n            width: \"100%\",\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0\n          } : {\n            overflow: \"visible\",\n            position: \"relative\",\n            width: \"100%\",\n            height: \"auto\",\n            top: \"auto\",\n            bottom: \"auto\",\n            left: \"auto\",\n            right: \"auto\"\n          });\n          return this;\n        }\n        return wrapper;\n      };\n      this.effects = function (targets, config) {\n        var _effects;\n        effects || (effects = []);\n        if (!targets) {\n          return effects.slice(0);\n        }\n        targets = _toArray(targets);\n        targets.forEach(function (target) {\n          var i = effects.length;\n          while (i--) {\n            effects[i].trigger === target && effects[i].kill();\n          }\n        });\n        config = config || {};\n        var _config = config,\n          speed = _config.speed,\n          lag = _config.lag,\n          effectsPadding = _config.effectsPadding,\n          effectsToAdd = [],\n          i,\n          st;\n        for (i = 0; i < targets.length; i++) {\n          st = createEffect(targets[i], speed, lag, i, effectsPadding);\n          st && effectsToAdd.push(st);\n        }\n        (_effects = effects).push.apply(_effects, effectsToAdd);\n        return effectsToAdd;\n      };\n      this.sections = function (targets, config) {\n        var _sections;\n        sections || (sections = []);\n        if (!targets) {\n          return sections.slice(0);\n        }\n        var newSections = _toArray(targets).map(function (el) {\n          return ScrollTrigger.create({\n            trigger: el,\n            start: \"top 120%\",\n            end: \"bottom -20%\",\n            onToggle: function onToggle(self) {\n              el.style.opacity = self.isActive ? \"1\" : \"0\";\n              el.style.pointerEvents = self.isActive ? \"all\" : \"none\";\n            }\n          });\n        });\n        config && config.add ? (_sections = sections).push.apply(_sections, newSections) : sections = newSections.slice(0);\n        return newSections;\n      };\n      this.content(vars.content);\n      this.wrapper(vars.wrapper);\n      this.render = function (y) {\n        return render(y || y === 0 ? y : currentY);\n      };\n      this.getVelocity = function () {\n        return tracker.getVelocity(-currentY);\n      };\n      ScrollTrigger.scrollerProxy(wrapper, {\n        scrollTop: scrollTop,\n        scrollHeight: function scrollHeight() {\n          return refreshHeight() && _body.scrollHeight;\n        },\n        fixedMarkers: vars.fixedMarkers !== false && !!smoothDuration,\n        content: content,\n        getBoundingClientRect: function getBoundingClientRect() {\n          return {\n            top: 0,\n            left: 0,\n            width: _win.innerWidth,\n            height: _win.innerHeight\n          };\n        }\n      });\n      ScrollTrigger.defaults({\n        scroller: wrapper\n      });\n      var existingScrollTriggers = ScrollTrigger.getAll().filter(function (st) {\n        return st.scroller === _win || st.scroller === wrapper;\n      });\n      existingScrollTriggers.forEach(function (st) {\n        return st.revert(true, true);\n      });\n      mainST = ScrollTrigger.create({\n        animation: gsap.fromTo(scroll, {\n          y: 0\n        }, {\n          y: function y() {\n            return -refreshHeight();\n          },\n          immediateRender: false,\n          ease: \"none\",\n          data: \"ScrollSmoother\",\n          duration: 100,\n          onUpdate: function onUpdate() {\n            if (this._dur) {\n              var force = isProxyScrolling;\n              if (force) {\n                killScrub(mainST);\n                scroll.y = currentY;\n              }\n              render(scroll.y, force);\n              updateVelocity();\n              _onUpdate && !paused && _onUpdate(self);\n            }\n          }\n        }),\n        onRefreshInit: function onRefreshInit(self) {\n          if (ScrollSmoother.isRefreshing) {\n            return;\n          }\n          ScrollSmoother.isRefreshing = true;\n          if (effects) {\n            var _pins = ScrollTrigger.getAll().filter(function (st) {\n              return !!st.pin;\n            });\n            effects.forEach(function (st) {\n              if (!st.vars.pinnedContainer) {\n                _pins.forEach(function (pinST) {\n                  if (pinST.pin.contains(st.trigger)) {\n                    var v = st.vars;\n                    v.pinnedContainer = pinST.pin;\n                    st.vars = null;\n                    st.init(v, st.animation);\n                  }\n                });\n              }\n            });\n          }\n          var scrub = self.getTween();\n          recordedRefreshScrub = scrub && scrub._end > scrub._dp._time;\n          recordedRefreshScroll = currentY;\n          scroll.y = 0;\n          if (smoothDuration) {\n            ScrollTrigger.isTouch === 1 && (wrapper.style.position = \"absolute\");\n            wrapper.scrollTop = 0;\n            ScrollTrigger.isTouch === 1 && (wrapper.style.position = \"fixed\");\n          }\n        },\n        onRefresh: function onRefresh(self) {\n          self.animation.invalidate();\n          self.setPositions(self.start, refreshHeight() / speed);\n          recordedRefreshScrub || killScrub(self);\n          scroll.y = -scrollFunc() * speed;\n          render(scroll.y);\n          startupPhase || self.animation.progress(gsap.utils.clamp(0, 1, recordedRefreshScroll / speed / -self.end));\n          if (recordedRefreshScrub) {\n            self.progress -= 0.001;\n            self.update();\n          }\n          ScrollSmoother.isRefreshing = false;\n        },\n        id: \"ScrollSmoother\",\n        scroller: _win,\n        invalidateOnRefresh: true,\n        start: 0,\n        refreshPriority: -9999,\n        end: function end() {\n          return refreshHeight() / speed;\n        },\n        onScrubComplete: function onScrubComplete() {\n          tracker.reset();\n          onStop && onStop(_this);\n        },\n        scrub: smoothDuration || true\n      });\n      this.smooth = function (value) {\n        if (arguments.length) {\n          smoothDuration = value || 0;\n          speed = smoothDuration && +vars.speed || 1;\n          mainST.scrubDuration(value);\n        }\n        return mainST.getTween() ? mainST.getTween().duration() : 0;\n      };\n      mainST.getTween() && (mainST.getTween().vars.ease = vars.ease || _expo);\n      this.scrollTrigger = mainST;\n      vars.effects && this.effects(vars.effects === true ? \"[data-\" + effectsPrefix + \"speed], [data-\" + effectsPrefix + \"lag]\" : vars.effects, {\n        effectsPadding: vars.effectsPadding\n      });\n      vars.sections && this.sections(vars.sections === true ? \"[data-section]\" : vars.sections);\n      existingScrollTriggers.forEach(function (st) {\n        st.vars.scroller = wrapper;\n        st.revert(false, true);\n        st.init(st.vars, st.animation);\n      });\n      this.paused = function (value, allowNestedScroll) {\n        if (arguments.length) {\n          if (!!paused !== value) {\n            if (value) {\n              mainST.getTween() && mainST.getTween().pause();\n              scrollFunc(-currentY / speed);\n              tracker.reset();\n              pausedNormalizer = ScrollTrigger.normalizeScroll();\n              pausedNormalizer && pausedNormalizer.disable();\n              paused = ScrollTrigger.observe({\n                preventDefault: true,\n                type: \"wheel,touch,scroll\",\n                debounce: false,\n                allowClicks: true,\n                onChangeY: function onChangeY() {\n                  return scrollTop(-currentY);\n                }\n              });\n              paused.nested = _inputObserver(_docEl, \"wheel,touch,scroll\", true, allowNestedScroll !== false);\n            } else {\n              paused.nested.kill();\n              paused.kill();\n              paused = 0;\n              pausedNormalizer && pausedNormalizer.enable();\n              mainST.progress = (-currentY / speed - mainST.start) / (mainST.end - mainST.start);\n              killScrub(mainST);\n            }\n          }\n          return this;\n        }\n        return !!paused;\n      };\n      this.kill = this.revert = function () {\n        _this.paused(false);\n        killScrub(mainST);\n        mainST.kill();\n        var triggers = (effects || []).concat(sections || []),\n          i = triggers.length;\n        while (i--) {\n          triggers[i].kill();\n        }\n        ScrollTrigger.scrollerProxy(wrapper);\n        ScrollTrigger.removeEventListener(\"killAll\", addOnRefresh);\n        ScrollTrigger.removeEventListener(\"refresh\", onRefresh);\n        wrapper.style.cssText = wrapperCSS;\n        content.style.cssText = contentCSS;\n        var defaults = ScrollTrigger.defaults({});\n        defaults && defaults.scroller === wrapper && ScrollTrigger.defaults({\n          scroller: _win\n        });\n        _this.normalizer && ScrollTrigger.normalizeScroll(false);\n        clearInterval(intervalID);\n        _mainInstance = null;\n        resizeObserver && resizeObserver.disconnect();\n        _body.style.removeProperty(\"height\");\n        _win.removeEventListener(\"focusin\", _onFocusIn);\n      };\n      this.refresh = function (soft, force) {\n        return mainST.refresh(soft, force);\n      };\n      if (normalizeScroll) {\n        this.normalizer = ScrollTrigger.normalizeScroll(normalizeScroll === true ? {\n          debounce: true,\n          content: !smoothDuration && content\n        } : normalizeScroll);\n      }\n      ScrollTrigger.config(vars);\n      \"overscrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n        overscrollBehavior: \"none\"\n      });\n      \"scrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n        scrollBehavior: \"auto\"\n      });\n      _win.addEventListener(\"focusin\", _onFocusIn);\n      intervalID = setInterval(updateVelocity, 250);\n      _doc.readyState === \"loading\" || requestAnimationFrame(function () {\n        return ScrollTrigger.refresh();\n      });\n    }\n    ScrollSmoother.register = function register(core) {\n      if (!_coreInitted) {\n        gsap = core || _getGSAP();\n        if (_windowExists() && window.document) {\n          _win = window;\n          _doc = document;\n          _docEl = _doc.documentElement;\n          _body = _doc.body;\n        }\n        if (gsap) {\n          _toArray = gsap.utils.toArray;\n          _clamp = gsap.utils.clamp;\n          _expo = gsap.parseEase(\"expo\");\n          _context = gsap.core.context || function () {};\n          ScrollTrigger = gsap.core.globals().ScrollTrigger;\n          gsap.core.globals(\"ScrollSmoother\", ScrollSmoother);\n          if (_body && ScrollTrigger) {\n            _onResizeDelayedCall = gsap.delayedCall(0.2, function () {\n              return ScrollTrigger.isRefreshing || _mainInstance && _mainInstance.refresh();\n            }).pause();\n            _getVelocityProp = ScrollTrigger.core._getVelocityProp;\n            _inputObserver = ScrollTrigger.core._inputObserver;\n            ScrollSmoother.refresh = ScrollTrigger.refresh;\n            _coreInitted = 1;\n          }\n        }\n      }\n      return _coreInitted;\n    };\n    _createClass(ScrollSmoother, [{\n      key: \"progress\",\n      get: function get() {\n        return this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0;\n      }\n    }]);\n    return ScrollSmoother;\n  }();\n  ScrollSmoother.version = \"3.12.2\";\n  ScrollSmoother.create = function (vars) {\n    return _mainInstance && vars && _mainInstance.content() === _toArray(vars.content)[0] ? _mainInstance : new ScrollSmoother(vars);\n  };\n  ScrollSmoother.get = function () {\n    return _mainInstance;\n  };\n  _getGSAP() && gsap.registerPlugin(ScrollSmoother);\n  exports.ScrollSmoother = ScrollSmoother;\n  exports.default = ScrollSmoother;\n  if (typeof window === 'undefined' || window !== exports) {\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n  } else {\n    delete window.default;\n  }\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","window","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","gsap","_coreInitted","_win","_doc","_docEl","_body","_toArray","_clamp","ScrollTrigger","_mainInstance","_expo","_getVelocityProp","_inputObserver","_context","_onResizeDelayedCall","_windowExists","_getGSAP","registerPlugin","_round","value","Math","round","_maxScroll","scroller","maxScroll","_autoDistance","el","progress","parent","parentNode","b1","getBoundingClientRect","b2","gapTop","top","gapBottom","bottom","change","abs","offset","ratio","extraChange","height","innerHeight","min","_wrap","wrapper","querySelector","createElement","classList","add","insertBefore","appendChild","ScrollSmoother","vars","_this","register","console","warn","kill","_vars","smoothTouch","_onUpdate","onUpdate","onStop","smooth","onFocusIn","normalizeScroll","wholePixels","content","mainST","effects","sections","intervalID","wrapperCSS","contentCSS","paused","pausedNormalizer","recordedRefreshScroll","recordedRefreshScrub","effectsPrefix","scrollFunc","getScrollFunc","smoothDuration","isTouch","parseFloat","speed","currentY","delta","startupPhase","tracker","updateVelocity","update","scroll","y","removeScroll","style","overflow","isProxyScrolling","killScrub","trigger","scrub","getTween","pause","_time","_dur","_tTime","_tDur","animation","render","force","transform","_gsap","isUpdating","isRefreshing","scrollTop","arguments","resizeObserver","ResizeObserver","autoResize","max","restart","lastFocusElement","_onFocusIn","e","contains","isInViewport","scrollTo","_transformPosition","position","st","start","isNaN","end","distance","pins","pinOffset","progressOffset","_startClamp","_endClamp","forEach","p","nativeStart","adjustEffectRelatedTriggers","triggers","partial","markers","dif","isClamped","nativeEnd","trig","pinnedContainer","_startNative","_endNative","pin","setPositions","markerStart","push","quickSetter","markerEnd","adjustParallaxPosition","createdAfterEffectWasApplied","onRefresh","requestAnimationFrame","getAll","autoSpeed","s","sort","reset","addOnRefresh","addEventListener","restoreEffects","revertEffects","onRefreshInit","effectValueGetter","name","index","v","getAttribute","setAttribute","clamp","substr","createEffect","lag","effectsPadding","getSpeed","getLag","startY","getProperty","cache","yOffset","initDynamicValues","to","ease","overwrite","duration","revert","renderTransform","updateChange","auto","create","refreshPriority","onKill","indexOf","splice","extraY","scrollY","isActive","direction","resetTo","utils","setter","core","getCache","stRevert","willChange","delayedCall","cssText","refresh","uncache","refreshHeight","clientHeight","element","newContent","children","observe","set","width","boxSizing","clearProps","left","right","targets","config","_effects","slice","_config","effectsToAdd","apply","_sections","newSections","map","onToggle","opacity","pointerEvents","getVelocity","scrollerProxy","scrollHeight","fixedMarkers","innerWidth","defaults","existingScrollTriggers","filter","fromTo","immediateRender","data","_pins","pinST","init","_end","_dp","invalidate","id","invalidateOnRefresh","onScrubComplete","scrubDuration","scrollTrigger","allowNestedScroll","disable","preventDefault","type","debounce","allowClicks","onChangeY","nested","enable","concat","removeEventListener","normalizer","clearInterval","disconnect","removeProperty","soft","getComputedStyle","overscrollBehavior","scrollBehavior","setInterval","readyState","document","documentElement","body","toArray","parseEase","context","globals","get","version","default"],"sources":["C:/Users/Kamal/Desktop/stephen/landing-page/node_modules/gsap/dist/ScrollSmoother.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.window = global.window || {}));\n}(this, (function (exports) { 'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  /*!\n   * ScrollSmoother 3.12.2\n   * https://greensock.com\n   *\n   * @license Copyright 2008-2023, GreenSock. All rights reserved.\n   * Subject to the terms at https://greensock.com/standard-license or for\n   * Club GreenSock members, the agreement issued with that membership.\n   * @author: Jack Doyle, jack@greensock.com\n  */\n  var gsap,\n      _coreInitted,\n      _win,\n      _doc,\n      _docEl,\n      _body,\n      _toArray,\n      _clamp,\n      ScrollTrigger,\n      _mainInstance,\n      _expo,\n      _getVelocityProp,\n      _inputObserver,\n      _context,\n      _onResizeDelayedCall,\n      _windowExists = function _windowExists() {\n    return typeof window !== \"undefined\";\n  },\n      _getGSAP = function _getGSAP() {\n    return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n  },\n      _round = function _round(value) {\n    return Math.round(value * 100000) / 100000 || 0;\n  },\n      _maxScroll = function _maxScroll(scroller) {\n    return ScrollTrigger.maxScroll(scroller || _win);\n  },\n      _autoDistance = function _autoDistance(el, progress) {\n    var parent = el.parentNode || _docEl,\n        b1 = el.getBoundingClientRect(),\n        b2 = parent.getBoundingClientRect(),\n        gapTop = b2.top - b1.top,\n        gapBottom = b2.bottom - b1.bottom,\n        change = (Math.abs(gapTop) > Math.abs(gapBottom) ? gapTop : gapBottom) / (1 - progress),\n        offset = -change * progress,\n        ratio,\n        extraChange;\n\n    if (change > 0) {\n      ratio = b2.height / (_win.innerHeight + b2.height);\n      extraChange = ratio === 0.5 ? b2.height * 2 : Math.min(b2.height, Math.abs(-change * ratio / (2 * ratio - 1))) * 2 * (progress || 1);\n      offset += progress ? -extraChange * progress : -extraChange / 2;\n      change += extraChange;\n    }\n\n    return {\n      change: change,\n      offset: offset\n    };\n  },\n      _wrap = function _wrap(el) {\n    var wrapper = _doc.querySelector(\".ScrollSmoother-wrapper\");\n\n    if (!wrapper) {\n      wrapper = _doc.createElement(\"div\");\n      wrapper.classList.add(\"ScrollSmoother-wrapper\");\n      el.parentNode.insertBefore(wrapper, el);\n      wrapper.appendChild(el);\n    }\n\n    return wrapper;\n  };\n\n  var ScrollSmoother = function () {\n    function ScrollSmoother(vars) {\n      var _this = this;\n\n      _coreInitted || ScrollSmoother.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollSmoother)\");\n      vars = this.vars = vars || {};\n      _mainInstance && _mainInstance.kill();\n      _mainInstance = this;\n\n      _context(this);\n\n      var _vars = vars,\n          smoothTouch = _vars.smoothTouch,\n          _onUpdate = _vars.onUpdate,\n          onStop = _vars.onStop,\n          smooth = _vars.smooth,\n          onFocusIn = _vars.onFocusIn,\n          normalizeScroll = _vars.normalizeScroll,\n          wholePixels = _vars.wholePixels,\n          content,\n          wrapper,\n          height,\n          mainST,\n          effects,\n          sections,\n          intervalID,\n          wrapperCSS,\n          contentCSS,\n          paused,\n          pausedNormalizer,\n          recordedRefreshScroll,\n          recordedRefreshScrub,\n          self = this,\n          effectsPrefix = vars.effectsPrefix || \"\",\n          scrollFunc = ScrollTrigger.getScrollFunc(_win),\n          smoothDuration = ScrollTrigger.isTouch === 1 ? smoothTouch === true ? 0.8 : parseFloat(smoothTouch) || 0 : smooth === 0 || smooth === false ? 0 : parseFloat(smooth) || 0.8,\n          speed = smoothDuration && +vars.speed || 1,\n          currentY = 0,\n          delta = 0,\n          startupPhase = 1,\n          tracker = _getVelocityProp(0),\n          updateVelocity = function updateVelocity() {\n        return tracker.update(-currentY);\n      },\n          scroll = {\n        y: 0\n      },\n          removeScroll = function removeScroll() {\n        return content.style.overflow = \"visible\";\n      },\n          isProxyScrolling,\n          killScrub = function killScrub(trigger) {\n        trigger.update();\n        var scrub = trigger.getTween();\n\n        if (scrub) {\n          scrub.pause();\n          scrub._time = scrub._dur;\n          scrub._tTime = scrub._tDur;\n        }\n\n        isProxyScrolling = false;\n        trigger.animation.progress(trigger.progress, true);\n      },\n          render = function render(y, force) {\n        if (y !== currentY && !paused || force) {\n          wholePixels && (y = Math.round(y));\n\n          if (smoothDuration) {\n            content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\";\n            content._gsap.y = y + \"px\";\n          }\n\n          delta = y - currentY;\n          currentY = y;\n          ScrollTrigger.isUpdating || ScrollSmoother.isRefreshing || ScrollTrigger.update();\n        }\n      },\n          scrollTop = function scrollTop(value) {\n        if (arguments.length) {\n          value < 0 && (value = 0);\n          scroll.y = -value;\n          isProxyScrolling = true;\n          paused ? currentY = -value : render(-value);\n          ScrollTrigger.isRefreshing ? mainST.update() : scrollFunc(value / speed);\n          return this;\n        }\n\n        return -currentY;\n      },\n          resizeObserver = typeof ResizeObserver !== \"undefined\" && vars.autoResize !== false && new ResizeObserver(function () {\n        if (!ScrollTrigger.isRefreshing) {\n          var max = _maxScroll(wrapper) * speed;\n          max < -currentY && scrollTop(max);\n\n          _onResizeDelayedCall.restart(true);\n        }\n      }),\n          lastFocusElement,\n          _onFocusIn = function _onFocusIn(e) {\n        wrapper.scrollTop = 0;\n\n        if (e.target.contains && e.target.contains(wrapper) || onFocusIn && onFocusIn(_this, e) === false) {\n          return;\n        }\n\n        ScrollTrigger.isInViewport(e.target) || e.target === lastFocusElement || _this.scrollTo(e.target, false, \"center center\");\n        lastFocusElement = e.target;\n      },\n          _transformPosition = function _transformPosition(position, st) {\n        if (position < st.start) {\n          return position;\n        }\n\n        var ratio = isNaN(st.ratio) ? 1 : st.ratio,\n            change = st.end - st.start,\n            distance = position - st.start,\n            offset = st.offset || 0,\n            pins = st.pins || [],\n            pinOffset = pins.offset || 0,\n            progressOffset = st._startClamp && st.start <= 0 || st.pins && st.pins.offset ? 0 : st._endClamp && st.end === _maxScroll() ? 1 : 0.5;\n        pins.forEach(function (p) {\n          change -= p.distance;\n\n          if (p.nativeStart <= position) {\n            distance -= p.distance;\n          }\n        });\n\n        if (pinOffset) {\n          distance *= (change - pinOffset / ratio) / change;\n        }\n\n        return position + (distance - offset * progressOffset) / ratio - distance;\n      },\n          adjustEffectRelatedTriggers = function adjustEffectRelatedTriggers(st, triggers, partial) {\n        partial || (st.pins.length = st.pins.offset = 0);\n        var pins = st.pins,\n            markers = st.markers,\n            dif,\n            isClamped,\n            start,\n            end,\n            nativeStart,\n            nativeEnd,\n            i,\n            trig;\n\n        for (i = 0; i < triggers.length; i++) {\n          trig = triggers[i];\n\n          if (st.trigger && trig.trigger && st !== trig && (trig.trigger === st.trigger || trig.pinnedContainer === st.trigger || st.trigger.contains(trig.trigger))) {\n            nativeStart = trig._startNative || trig._startClamp || trig.start;\n            nativeEnd = trig._endNative || trig._endClamp || trig.end;\n            start = _transformPosition(nativeStart, st);\n            end = trig.pin && nativeEnd > 0 ? start + (nativeEnd - nativeStart) : _transformPosition(nativeEnd, st);\n            trig.setPositions(start, end, true, (trig._startClamp ? Math.max(0, start) : start) - nativeStart);\n            trig.markerStart && markers.push(gsap.quickSetter([trig.markerStart, trig.markerEnd], \"y\", \"px\"));\n\n            if (trig.pin && trig.end > 0 && !partial) {\n              dif = trig.end - trig.start;\n              isClamped = st._startClamp && trig.start < 0;\n\n              if (isClamped) {\n                if (st.start > 0) {\n                  st.setPositions(0, st.end + (st._startNative - st.start), true);\n                  adjustEffectRelatedTriggers(st, triggers);\n                  return;\n                }\n\n                dif += trig.start;\n                pins.offset = -trig.start;\n              }\n\n              pins.push({\n                start: trig.start,\n                nativeStart: nativeStart,\n                end: trig.end,\n                distance: dif,\n                trig: trig\n              });\n              st.setPositions(st.start, st.end + (isClamped ? -trig.start : dif), true);\n            }\n          }\n        }\n      },\n          adjustParallaxPosition = function adjustParallaxPosition(triggers, createdAfterEffectWasApplied) {\n        effects.forEach(function (st) {\n          return adjustEffectRelatedTriggers(st, triggers, createdAfterEffectWasApplied);\n        });\n      },\n          onRefresh = function onRefresh() {\n        removeScroll();\n        requestAnimationFrame(removeScroll);\n\n        if (effects) {\n          ScrollTrigger.getAll().forEach(function (st) {\n            st._startNative = st.start;\n            st._endNative = st.end;\n          });\n          effects.forEach(function (st) {\n            var start = st._startClamp || st.start,\n                end = st.autoSpeed ? Math.min(_maxScroll(), st.end) : start + Math.abs((st.end - start) / st.ratio),\n                offset = end - st.end;\n            start -= offset / 2;\n            end -= offset / 2;\n\n            if (start > end) {\n              var s = start;\n              start = end;\n              end = s;\n            }\n\n            if (st._startClamp && start < 0) {\n              end = st.ratio < 0 ? _maxScroll() : st.end / st.ratio;\n              offset = end - st.end;\n              start = 0;\n            } else if (st.ratio < 0 || st._endClamp && end >= _maxScroll()) {\n              end = _maxScroll();\n              start = st.ratio < 0 ? 0 : st.ratio > 1 ? 0 : end - (end - st.start) / st.ratio;\n              offset = (end - start) * st.ratio - (st.end - st.start);\n            }\n\n            st.offset = offset || 0.0001;\n            st.pins.length = st.pins.offset = 0;\n            st.setPositions(start, end, true);\n          });\n          adjustParallaxPosition(ScrollTrigger.sort());\n        }\n\n        tracker.reset();\n      },\n          addOnRefresh = function addOnRefresh() {\n        return ScrollTrigger.addEventListener(\"refresh\", onRefresh);\n      },\n          restoreEffects = function restoreEffects() {\n        return effects && effects.forEach(function (st) {\n          return st.vars.onRefresh(st);\n        });\n      },\n          revertEffects = function revertEffects() {\n        effects && effects.forEach(function (st) {\n          return st.vars.onRefreshInit(st);\n        });\n        return restoreEffects;\n      },\n          effectValueGetter = function effectValueGetter(name, value, index, el) {\n        return function () {\n          var v = typeof value === \"function\" ? value(index, el) : value;\n          v || v === 0 || (v = el.getAttribute(\"data-\" + effectsPrefix + name) || (name === \"speed\" ? 1 : 0));\n          el.setAttribute(\"data-\" + effectsPrefix + name, v);\n          var clamp = (v + \"\").substr(0, 6) === \"clamp(\";\n          return {\n            clamp: clamp,\n            value: clamp ? v.substr(6, v.length - 7) : v\n          };\n        };\n      },\n          createEffect = function createEffect(el, speed, lag, index, effectsPadding) {\n        effectsPadding = (typeof effectsPadding === \"function\" ? effectsPadding(index, el) : effectsPadding) || 0;\n\n        var getSpeed = effectValueGetter(\"speed\", speed, index, el),\n            getLag = effectValueGetter(\"lag\", lag, index, el),\n            startY = gsap.getProperty(el, \"y\"),\n            cache = el._gsap,\n            ratio,\n            st,\n            autoSpeed,\n            scrub,\n            progressOffset,\n            yOffset,\n            pins = [],\n            initDynamicValues = function initDynamicValues() {\n          speed = getSpeed();\n          lag = parseFloat(getLag().value);\n          ratio = parseFloat(speed.value) || 1;\n          autoSpeed = speed.value === \"auto\";\n          progressOffset = autoSpeed || st && st._startClamp && st.start <= 0 || pins.offset ? 0 : st && st._endClamp && st.end === _maxScroll() ? 1 : 0.5;\n          scrub && scrub.kill();\n          scrub = lag && gsap.to(el, {\n            ease: _expo,\n            overwrite: false,\n            y: \"+=0\",\n            duration: lag\n          });\n\n          if (st) {\n            st.ratio = ratio;\n            st.autoSpeed = autoSpeed;\n          }\n        },\n            revert = function revert() {\n          cache.y = startY + \"px\";\n          cache.renderTransform(1);\n          initDynamicValues();\n        },\n            markers = [],\n            change = 0,\n            updateChange = function updateChange(self) {\n          if (autoSpeed) {\n            revert();\n\n            var auto = _autoDistance(el, _clamp(0, 1, -self.start / (self.end - self.start)));\n\n            change = auto.change;\n            yOffset = auto.offset;\n          } else {\n            yOffset = pins.offset || 0;\n            change = (self.end - self.start - yOffset) * (1 - ratio);\n          }\n\n          pins.forEach(function (p) {\n            return change -= p.distance * (1 - ratio);\n          });\n          self.offset = change || 0.001;\n          self.vars.onUpdate(self);\n          scrub && scrub.progress(1);\n        };\n\n        initDynamicValues();\n\n        if (ratio !== 1 || autoSpeed || scrub) {\n          st = ScrollTrigger.create({\n            trigger: autoSpeed ? el.parentNode : el,\n            start: function start() {\n              return speed.clamp ? \"clamp(top bottom+=\" + effectsPadding + \")\" : \"top bottom+=\" + effectsPadding;\n            },\n            end: function end() {\n              return speed.value < 0 ? \"max\" : speed.clamp ? \"clamp(bottom top-=\" + effectsPadding + \")\" : \"bottom top-=\" + effectsPadding;\n            },\n            scroller: wrapper,\n            scrub: true,\n            refreshPriority: -999,\n            onRefreshInit: revert,\n            onRefresh: updateChange,\n            onKill: function onKill(self) {\n              var i = effects.indexOf(self);\n              i >= 0 && effects.splice(i, 1);\n              revert();\n            },\n            onUpdate: function onUpdate(self) {\n              var y = startY + change * (self.progress - progressOffset),\n                  i = pins.length,\n                  extraY = 0,\n                  pin,\n                  scrollY,\n                  end;\n\n              if (self.offset) {\n                if (i) {\n                  scrollY = -currentY;\n                  end = self.end;\n\n                  while (i--) {\n                    pin = pins[i];\n\n                    if (pin.trig.isActive || scrollY >= pin.start && scrollY <= pin.end) {\n                      if (scrub) {\n                        pin.trig.progress += pin.trig.direction < 0 ? 0.001 : -0.001;\n                        pin.trig.update(0, 0, 1);\n                        scrub.resetTo(\"y\", parseFloat(cache.y), -delta, true);\n                        startupPhase && scrub.progress(1);\n                      }\n\n                      return;\n                    }\n\n                    scrollY > pin.end && (extraY += pin.distance);\n                    end -= pin.distance;\n                  }\n\n                  y = startY + extraY + change * ((gsap.utils.clamp(self.start, self.end, scrollY) - self.start - extraY) / (end - self.start) - progressOffset);\n                }\n\n                markers.length && !autoSpeed && markers.forEach(function (setter) {\n                  return setter(y - extraY);\n                });\n                y = _round(y + yOffset);\n\n                if (scrub) {\n                  scrub.resetTo(\"y\", y, -delta, true);\n                  startupPhase && scrub.progress(1);\n                } else {\n                  cache.y = y + \"px\";\n                  cache.renderTransform(1);\n                }\n              }\n            }\n          });\n          updateChange(st);\n          gsap.core.getCache(st.trigger).stRevert = revertEffects;\n          st.startY = startY;\n          st.pins = pins;\n          st.markers = markers;\n          st.ratio = ratio;\n          st.autoSpeed = autoSpeed;\n          el.style.willChange = \"transform\";\n        }\n\n        return st;\n      };\n\n      addOnRefresh();\n      ScrollTrigger.addEventListener(\"killAll\", addOnRefresh);\n      gsap.delayedCall(0.5, function () {\n        return startupPhase = 0;\n      });\n      this.scrollTop = scrollTop;\n\n      this.scrollTo = function (target, smooth, position) {\n        var p = gsap.utils.clamp(0, _maxScroll(), isNaN(target) ? _this.offset(target, position) : +target);\n        !smooth ? scrollTop(p) : paused ? gsap.to(_this, {\n          duration: smoothDuration,\n          scrollTop: p,\n          overwrite: \"auto\",\n          ease: _expo\n        }) : scrollFunc(p);\n      };\n\n      this.offset = function (target, position) {\n        target = _toArray(target)[0];\n        var cssText = target.style.cssText,\n            st = ScrollTrigger.create({\n          trigger: target,\n          start: position || \"top top\"\n        }),\n            y;\n\n        if (effects) {\n          startupPhase ? ScrollTrigger.refresh() : adjustParallaxPosition([st], true);\n        }\n\n        y = st.start / speed;\n        st.kill(false);\n        target.style.cssText = cssText;\n        gsap.core.getCache(target).uncache = 1;\n        return y;\n      };\n\n      function refreshHeight() {\n        height = content.clientHeight;\n        content.style.overflow = \"visible\";\n        _body.style.height = _win.innerHeight + (height - _win.innerHeight) / speed + \"px\";\n        return height - _win.innerHeight;\n      }\n\n      this.content = function (element) {\n        if (arguments.length) {\n          var newContent = _toArray(element || \"#smooth-content\")[0] || console.warn(\"ScrollSmoother needs a valid content element.\") || _body.children[0];\n\n          if (newContent !== content) {\n            content = newContent;\n            contentCSS = content.getAttribute(\"style\") || \"\";\n            resizeObserver && resizeObserver.observe(content);\n            gsap.set(content, {\n              overflow: \"visible\",\n              width: \"100%\",\n              boxSizing: \"border-box\",\n              y: \"+=0\"\n            });\n            smoothDuration || gsap.set(content, {\n              clearProps: \"transform\"\n            });\n          }\n\n          return this;\n        }\n\n        return content;\n      };\n\n      this.wrapper = function (element) {\n        if (arguments.length) {\n          wrapper = _toArray(element || \"#smooth-wrapper\")[0] || _wrap(content);\n          wrapperCSS = wrapper.getAttribute(\"style\") || \"\";\n          refreshHeight();\n          gsap.set(wrapper, smoothDuration ? {\n            overflow: \"hidden\",\n            position: \"fixed\",\n            height: \"100%\",\n            width: \"100%\",\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0\n          } : {\n            overflow: \"visible\",\n            position: \"relative\",\n            width: \"100%\",\n            height: \"auto\",\n            top: \"auto\",\n            bottom: \"auto\",\n            left: \"auto\",\n            right: \"auto\"\n          });\n          return this;\n        }\n\n        return wrapper;\n      };\n\n      this.effects = function (targets, config) {\n        var _effects;\n\n        effects || (effects = []);\n\n        if (!targets) {\n          return effects.slice(0);\n        }\n\n        targets = _toArray(targets);\n        targets.forEach(function (target) {\n          var i = effects.length;\n\n          while (i--) {\n            effects[i].trigger === target && effects[i].kill();\n          }\n        });\n        config = config || {};\n        var _config = config,\n            speed = _config.speed,\n            lag = _config.lag,\n            effectsPadding = _config.effectsPadding,\n            effectsToAdd = [],\n            i,\n            st;\n\n        for (i = 0; i < targets.length; i++) {\n          st = createEffect(targets[i], speed, lag, i, effectsPadding);\n          st && effectsToAdd.push(st);\n        }\n\n        (_effects = effects).push.apply(_effects, effectsToAdd);\n\n        return effectsToAdd;\n      };\n\n      this.sections = function (targets, config) {\n        var _sections;\n\n        sections || (sections = []);\n\n        if (!targets) {\n          return sections.slice(0);\n        }\n\n        var newSections = _toArray(targets).map(function (el) {\n          return ScrollTrigger.create({\n            trigger: el,\n            start: \"top 120%\",\n            end: \"bottom -20%\",\n            onToggle: function onToggle(self) {\n              el.style.opacity = self.isActive ? \"1\" : \"0\";\n              el.style.pointerEvents = self.isActive ? \"all\" : \"none\";\n            }\n          });\n        });\n\n        config && config.add ? (_sections = sections).push.apply(_sections, newSections) : sections = newSections.slice(0);\n        return newSections;\n      };\n\n      this.content(vars.content);\n      this.wrapper(vars.wrapper);\n\n      this.render = function (y) {\n        return render(y || y === 0 ? y : currentY);\n      };\n\n      this.getVelocity = function () {\n        return tracker.getVelocity(-currentY);\n      };\n\n      ScrollTrigger.scrollerProxy(wrapper, {\n        scrollTop: scrollTop,\n        scrollHeight: function scrollHeight() {\n          return refreshHeight() && _body.scrollHeight;\n        },\n        fixedMarkers: vars.fixedMarkers !== false && !!smoothDuration,\n        content: content,\n        getBoundingClientRect: function getBoundingClientRect() {\n          return {\n            top: 0,\n            left: 0,\n            width: _win.innerWidth,\n            height: _win.innerHeight\n          };\n        }\n      });\n      ScrollTrigger.defaults({\n        scroller: wrapper\n      });\n      var existingScrollTriggers = ScrollTrigger.getAll().filter(function (st) {\n        return st.scroller === _win || st.scroller === wrapper;\n      });\n      existingScrollTriggers.forEach(function (st) {\n        return st.revert(true, true);\n      });\n      mainST = ScrollTrigger.create({\n        animation: gsap.fromTo(scroll, {\n          y: 0\n        }, {\n          y: function y() {\n            return -refreshHeight();\n          },\n          immediateRender: false,\n          ease: \"none\",\n          data: \"ScrollSmoother\",\n          duration: 100,\n          onUpdate: function onUpdate() {\n            if (this._dur) {\n              var force = isProxyScrolling;\n\n              if (force) {\n                killScrub(mainST);\n                scroll.y = currentY;\n              }\n\n              render(scroll.y, force);\n              updateVelocity();\n              _onUpdate && !paused && _onUpdate(self);\n            }\n          }\n        }),\n        onRefreshInit: function onRefreshInit(self) {\n          if (ScrollSmoother.isRefreshing) {\n            return;\n          }\n\n          ScrollSmoother.isRefreshing = true;\n\n          if (effects) {\n            var _pins = ScrollTrigger.getAll().filter(function (st) {\n              return !!st.pin;\n            });\n\n            effects.forEach(function (st) {\n              if (!st.vars.pinnedContainer) {\n                _pins.forEach(function (pinST) {\n                  if (pinST.pin.contains(st.trigger)) {\n                    var v = st.vars;\n                    v.pinnedContainer = pinST.pin;\n                    st.vars = null;\n                    st.init(v, st.animation);\n                  }\n                });\n              }\n            });\n          }\n\n          var scrub = self.getTween();\n          recordedRefreshScrub = scrub && scrub._end > scrub._dp._time;\n          recordedRefreshScroll = currentY;\n          scroll.y = 0;\n\n          if (smoothDuration) {\n            ScrollTrigger.isTouch === 1 && (wrapper.style.position = \"absolute\");\n            wrapper.scrollTop = 0;\n            ScrollTrigger.isTouch === 1 && (wrapper.style.position = \"fixed\");\n          }\n        },\n        onRefresh: function onRefresh(self) {\n          self.animation.invalidate();\n          self.setPositions(self.start, refreshHeight() / speed);\n          recordedRefreshScrub || killScrub(self);\n          scroll.y = -scrollFunc() * speed;\n          render(scroll.y);\n          startupPhase || self.animation.progress(gsap.utils.clamp(0, 1, recordedRefreshScroll / speed / -self.end));\n\n          if (recordedRefreshScrub) {\n            self.progress -= 0.001;\n            self.update();\n          }\n\n          ScrollSmoother.isRefreshing = false;\n        },\n        id: \"ScrollSmoother\",\n        scroller: _win,\n        invalidateOnRefresh: true,\n        start: 0,\n        refreshPriority: -9999,\n        end: function end() {\n          return refreshHeight() / speed;\n        },\n        onScrubComplete: function onScrubComplete() {\n          tracker.reset();\n          onStop && onStop(_this);\n        },\n        scrub: smoothDuration || true\n      });\n\n      this.smooth = function (value) {\n        if (arguments.length) {\n          smoothDuration = value || 0;\n          speed = smoothDuration && +vars.speed || 1;\n          mainST.scrubDuration(value);\n        }\n\n        return mainST.getTween() ? mainST.getTween().duration() : 0;\n      };\n\n      mainST.getTween() && (mainST.getTween().vars.ease = vars.ease || _expo);\n      this.scrollTrigger = mainST;\n      vars.effects && this.effects(vars.effects === true ? \"[data-\" + effectsPrefix + \"speed], [data-\" + effectsPrefix + \"lag]\" : vars.effects, {\n        effectsPadding: vars.effectsPadding\n      });\n      vars.sections && this.sections(vars.sections === true ? \"[data-section]\" : vars.sections);\n      existingScrollTriggers.forEach(function (st) {\n        st.vars.scroller = wrapper;\n        st.revert(false, true);\n        st.init(st.vars, st.animation);\n      });\n\n      this.paused = function (value, allowNestedScroll) {\n        if (arguments.length) {\n          if (!!paused !== value) {\n            if (value) {\n              mainST.getTween() && mainST.getTween().pause();\n              scrollFunc(-currentY / speed);\n              tracker.reset();\n              pausedNormalizer = ScrollTrigger.normalizeScroll();\n              pausedNormalizer && pausedNormalizer.disable();\n              paused = ScrollTrigger.observe({\n                preventDefault: true,\n                type: \"wheel,touch,scroll\",\n                debounce: false,\n                allowClicks: true,\n                onChangeY: function onChangeY() {\n                  return scrollTop(-currentY);\n                }\n              });\n              paused.nested = _inputObserver(_docEl, \"wheel,touch,scroll\", true, allowNestedScroll !== false);\n            } else {\n              paused.nested.kill();\n              paused.kill();\n              paused = 0;\n              pausedNormalizer && pausedNormalizer.enable();\n              mainST.progress = (-currentY / speed - mainST.start) / (mainST.end - mainST.start);\n              killScrub(mainST);\n            }\n          }\n\n          return this;\n        }\n\n        return !!paused;\n      };\n\n      this.kill = this.revert = function () {\n        _this.paused(false);\n\n        killScrub(mainST);\n        mainST.kill();\n        var triggers = (effects || []).concat(sections || []),\n            i = triggers.length;\n\n        while (i--) {\n          triggers[i].kill();\n        }\n\n        ScrollTrigger.scrollerProxy(wrapper);\n        ScrollTrigger.removeEventListener(\"killAll\", addOnRefresh);\n        ScrollTrigger.removeEventListener(\"refresh\", onRefresh);\n        wrapper.style.cssText = wrapperCSS;\n        content.style.cssText = contentCSS;\n        var defaults = ScrollTrigger.defaults({});\n        defaults && defaults.scroller === wrapper && ScrollTrigger.defaults({\n          scroller: _win\n        });\n        _this.normalizer && ScrollTrigger.normalizeScroll(false);\n        clearInterval(intervalID);\n        _mainInstance = null;\n        resizeObserver && resizeObserver.disconnect();\n\n        _body.style.removeProperty(\"height\");\n\n        _win.removeEventListener(\"focusin\", _onFocusIn);\n      };\n\n      this.refresh = function (soft, force) {\n        return mainST.refresh(soft, force);\n      };\n\n      if (normalizeScroll) {\n        this.normalizer = ScrollTrigger.normalizeScroll(normalizeScroll === true ? {\n          debounce: true,\n          content: !smoothDuration && content\n        } : normalizeScroll);\n      }\n\n      ScrollTrigger.config(vars);\n      \"overscrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n        overscrollBehavior: \"none\"\n      });\n      \"scrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n        scrollBehavior: \"auto\"\n      });\n\n      _win.addEventListener(\"focusin\", _onFocusIn);\n\n      intervalID = setInterval(updateVelocity, 250);\n      _doc.readyState === \"loading\" || requestAnimationFrame(function () {\n        return ScrollTrigger.refresh();\n      });\n    }\n\n    ScrollSmoother.register = function register(core) {\n      if (!_coreInitted) {\n        gsap = core || _getGSAP();\n\n        if (_windowExists() && window.document) {\n          _win = window;\n          _doc = document;\n          _docEl = _doc.documentElement;\n          _body = _doc.body;\n        }\n\n        if (gsap) {\n          _toArray = gsap.utils.toArray;\n          _clamp = gsap.utils.clamp;\n          _expo = gsap.parseEase(\"expo\");\n\n          _context = gsap.core.context || function () {};\n\n          ScrollTrigger = gsap.core.globals().ScrollTrigger;\n          gsap.core.globals(\"ScrollSmoother\", ScrollSmoother);\n\n          if (_body && ScrollTrigger) {\n            _onResizeDelayedCall = gsap.delayedCall(0.2, function () {\n              return ScrollTrigger.isRefreshing || _mainInstance && _mainInstance.refresh();\n            }).pause();\n            _getVelocityProp = ScrollTrigger.core._getVelocityProp;\n            _inputObserver = ScrollTrigger.core._inputObserver;\n            ScrollSmoother.refresh = ScrollTrigger.refresh;\n            _coreInitted = 1;\n          }\n        }\n      }\n\n      return _coreInitted;\n    };\n\n    _createClass(ScrollSmoother, [{\n      key: \"progress\",\n      get: function get() {\n        return this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0;\n      }\n    }]);\n\n    return ScrollSmoother;\n  }();\n  ScrollSmoother.version = \"3.12.2\";\n\n  ScrollSmoother.create = function (vars) {\n    return _mainInstance && vars && _mainInstance.content() === _toArray(vars.content)[0] ? _mainInstance : new ScrollSmoother(vars);\n  };\n\n  ScrollSmoother.get = function () {\n    return _mainInstance;\n  };\n\n  _getGSAP() && gsap.registerPlugin(ScrollSmoother);\n\n  exports.ScrollSmoother = ScrollSmoother;\n  exports.default = ScrollSmoother;\n\n  if (typeof(window) === 'undefined' || window !== exports) {Object.defineProperty(exports, '__esModule', { value: true });} else {delete window.default;}\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}